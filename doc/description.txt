ArnLib


Application
-----------
* If any graphics is used, Gui must be included.

* If only using QImage, Windowing system can be off like:
  QApplication a(argc, argv, false);


ScriptJobs
----------
* Each jobstack ScriptJobs is setup with a ScriptJobFactory wich makes custom interfaces etc.

* ScriptJobControl is setup with: Sriptfile, Config (QObject) and InterfaceList.
  Scriptfile is also copied to a ArnItem.

* ScriptJobControl can be connected to update of script in Arn, to make reload possible.

* Error text from ScriptJobControl can be connected to a pipe in Arn for logging.

* ScriptJobControl together with jobpriority define the ScriptJob and is added to ScriptJobs.
  Error text from Script job is connected to ScriptJobControl.

* Starting ScriptJobs in cooperative mode:
  a) Every ScriptJob is created and setup by corresponding ScriptJobControl
  b) Every ScriptJob is connected to Scheduler (yield etc).
  c) Every ScriptJobControl is connected to ScriptJobs for signaling update of script.
  d) Scheduler is started.

* Setup ScriptJob by ScriptJobControl:
  a) set ScriptJobFactory and Config
  b) Make and add the jobs Interfaces
  c) Evaluate the script (in js engine)
  d) run script function jobInit()

* Updating Script in cooperative mode:
  a) ScriptJobControl gets updated by Arn (or other).
  b) ScriptJobControl sends signal to ScriptJobs, which sets an updated flag for the corresponding Script Job.
  c) When scheduling, every updated script will get its sigQuit signal invoked and then reloaded.
  d) Reloading includes creating a new ScriptJob and setting up with ScriptJobControl etc.

* Starting ScriptJobs in preemtive mode:
  a) Every ScriptJob gets its own thread which also is setup with ScriptJobControl and ScriptJobFactory.
  b) Thread is started and it create a ScriptJobSingle where followning steps are done.
  c) ScriptJob is created and setup by ScriptJobControl
  d) ScriptJob is connected to Scheduler (yield etc).
  e) ScriptJobControl is connected to ScriptJobSingle for signaling update of script.
  f) Scheduler is started in ScriptJobSingle (just one job).

* Updating Script in preemtive mode:
  a) ScriptJobControl gets updated by Arn (or other).
  b) ScriptJobControl sends signal to ScriptJobSingle, which sets an updated flag
     and both invokes sigQuit signal to script and calls quit in scriptJob. 
  c) ScriptJob aborts its js script engine and posts a custom Quit event with high prio.
  d) When ScriptJob get the Quit event, it will send a QuitRequest signal to ScriptJobSingle.
  e) ScriptJobSingle will get the signal amd detect update flag, which means reloading.
  f) Reloading includes creating a new ScriptJob and setting up with ScriptJobControl etc.


ArnMonitor
----------
* Monitor starts its actual connection job when monitorPath is set.

* Monitor (at client-side) creates an ItemNet with path to monitorPath.

* The ItemNet is also put in syncQueue (always main-thread).

* Monitor puts the arn-event "monitorStart" in event loop,
  which makes sure event is sent after Monitor (and its caller) has finished initiializing.

* When "monitorStart" is received on local (client) side, the ItemNet will change SyncMode to Monitor.
  This will resync ItemNet to a Monitor at any server restart.

* Now 2 possibilities depending on threading:
  A) The ItemNet was sent before syncMode Monitor was set. Then server will receive an ordinary Itemnet and
     do standard setup.
  B) The ItemNet was sent with syncMode Monitor set. The server will detect this and do MonitorSetup on the ItemNet.

* When arn-event "monitorStart" is received on server-side, if SyncMode is not already set to "Monitor",
  server will do MonitorSetup on the ItemNet.

* When doing MonitorSetup (at server-side), connections are made to send arn-events when new childs are created,
  and present childs are directly sent as arn-event.


Destroy
-------
* Command arives with a netId.

* Corresponding ItemNet is disabled (set as defunct).

* All link-leaves for the ItemNet:s tree is set as retired and each leave is emitting a retired signal.

* The retired signal is handled by each connected Item. Each Item is sending a linkDestroyed signal to be handled by application code.
  The Items is finally closed and by this the link ref counter is decremented.

* When the links ref counter is reaching zero, a zeroRef signal is sent.

* The signal is handled by doZerRefLink(), in Main thread. It will set the link ref counter to -1 to mark the link as fully de-referenced.
  The link and parent (and grand parants ...) are deleted if they don't have any children and ref = -1 and they are retired.

* When the ItemNet is sending the linkDestroyed signal, it will be deleted from sync map and all queues.
  Finally a destroy command is sent with its netId, to spread the destruction to server and other clients.
